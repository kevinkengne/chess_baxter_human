#!/usr/bin/env python

""" Node handling the robot movements. 
Moves are generated by the python chess node and according to the measurements, 
Baxter can figure out how to properly move a piece on the board.  """

import sys
import copy
import rospy
from baxter_interface import Gripper
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from math import pi
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list
from measurements import on, above, outside_above, outside_on
import time

class BaxterSelfChess(object):
    """PickAndPlaceTutorial"""

    def __init__(self):
        left_gripper = Gripper('left')
        ## First initialize `moveit_commander`_ and a `rospy`_ node:
        joint_state_topic = ['joint_states:=/robot/joint_states']
        moveit_commander.roscpp_initialize(joint_state_topic)

        ## Instantiate a `RobotCommander`_ object. Provides information such as the robot's
        ## kinematic model and the robot's current joint states
        robot = moveit_commander.RobotCommander()

        ## Instantiate a `PlanningSceneInterface`_ object.  This provides a remote interface
        ## for getting, setting, and updating the robot's internal understanding of the
        ## surrounding world:
        scene = moveit_commander.PlanningSceneInterface()

        ## Instantiate a `MoveGroupCommander`_ object.  This object is an interface
        ## to a planning group (group of joints).
        ## This interface can be used to plan and execute motions:
        group_name = "left_arm"
        move_group = moveit_commander.MoveGroupCommander(group_name)

        # get the name of the reference frame for this robot:
        planning_frame = move_group.get_planning_frame()

        #  get a list of all the groups in thPickAndPlaceTutoriale robot:
        group_names = robot.get_group_names()

        #  get the name of the end-effector link for this group:
        eef_link = move_group.get_end_effector_link()
        # Misc variables
        self.box_name = ''
        self.robot = robot
        self.scene = scene
        self.move_group = move_group
        self.planning_frame = planning_frame
        self.eef_link = eef_link
        self.group_names = group_names
        self.left_gripper = left_gripper
        
        # List of all chess the moves to be executed by the robot 
        # will be filled in by subscribing to the topic where 
        # chess_moves_generator.py publishes moves
        self.moves = []

    def callback(self, data):
       # invoked with the message as the first argument when new messages are received
        move = data.data
        if move.endswith('s'):
            self.clean_square(move)
        self.make_chess_move(move)
        


    def chess_moves_subscribing(self):
        # Initialize the ROS node
        rospy.init_node('cube_test', anonymous=True)

        # Subscribe to the topic rendering the chess moves
        rospy.Subscriber('chess_next_moves', String, self.callback)

        # spin() simply keeps python from exiting until the node is stopped
        rospy.spin()


    def make_chess_move(self, next_move):
        first_location = next_move[:2]
        second_location = next_move[2:4]

        gripper = self.left_gripper

        move_group = self.move_group
        move_group.go(above[first_location])
        move_group.go(on[first_location])
        move_group.stop()
        gripper.calibrate()
        gripper.set_holding_force(90)

        gripper.close(True)
        move_group.go(above[first_location])
        move_group.go(above[second_location])
        move_group.go(on[second_location])
        move_group.stop()
        gripper.calibrate()
        gripper.open(True)
        move_group.go(above[second_location])
        move_group.go(outside_above)
        rospy.sleep(1.0)

    def clean_square(self, next_move):
        first_location = next_move[2:4]

        gripper = self.left_gripper
        move_group = self.move_group
        move_group.go(above[first_location])
        move_group.go(on[first_location])
        move_group.stop()
        gripper.calibrate()

        gripper.set_holding_force(90)
        gripper.close(True)
        move_group.go(above[first_location])
        move_group.go(outside_above)
        move_group.go(outside_on)
        move_group.stop()
        gripper.calibrate()
        gripper.open(True)
        move_group.go(outside_above)
        rospy.sleep(1.0)

def main():
    rospy.init_node('cube_test', anonymous=True)
    player = BaxterSelfChess() 
    player.chess_moves_subscribing
    
if __name__ == '__main__':
  main()